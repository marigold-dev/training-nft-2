#import "../common/assertions.jsligo" "Assertions"

#import "../common/errors.mligo" "Errors"

#import "../common/tzip12.datatypes.jsligo" "TZIP12"

#import "../common/tzip12.interfaces.jsligo" "TZIP12Interface"

#import "../common/tzip16.datatypes.jsligo" "TZIP16"

export namespace Datatypes {
   export type ledger = big_map<address, nat>;
   export type operator = address;
   export type operators = big_map<address, set<operator>>;
   export type storage = {
      ledger: ledger,
      operators: operators,
      token_metadata: TZIP12.tokenMetadata,
      metadata: TZIP16.metadata
   };
}

export namespace Sidecar {
   // operators 

   export const assert_authorisation = (
      operators: Datatypes.operators,
      from_: address
   ): unit => {
      const sender_ = Tezos.get_sender();
      if (sender_ == from_) return unit else {
         const authorized =
            match(Big_map.find_opt(from_, operators)) {
               when (Some(a)):
                  a
               when (None()):
                  Set.empty
            };
         if (Set.mem(sender_, authorized)) return unit else failwith(
            Errors.not_operator
         )
      }
   };
   export const add_operator = (
      operators: Datatypes.operators,
      owner: address,
      operator: Datatypes.operator
   ): Datatypes.operators => {
      if (owner == operator) return operators else {
         const _ = Assertions.assert_update_permission(owner);
         let auths =
            match(Big_map.find_opt(owner, operators)) {
               when (Some(os)):
                  os
               when (None()):
                  Set.empty
            };
         auths = Set.add(operator, auths);
         return Big_map.update(owner, Some(auths), operators)
      }
   };
   export const remove_operator = (
      operators: Datatypes.operators,
      owner: address,
      operator: Datatypes.operator
   ): Datatypes.operators => {
      if (owner == operator) return operators else {
         const _ = Assertions.assert_update_permission(owner);
         const auths =
            match(Big_map.find_opt(owner, operators)) {
               when (None()):
                  None()
               when (Some(ops)):
                  do {
                     let os = Set.remove(operator, ops);
                     if (Set.size(os) == 0n) return None() else return Some(os)
                  }
            };
         return Big_map.update(owner, auths, operators)
      }
   }
   // ledger 

   export const get_for_user = (ledger: Datatypes.ledger, owner: address): nat =>
      match(Big_map.find_opt(owner, ledger)) {
         when (Some(tokens)):
            tokens
         when (None()):
            0 as nat
      };
   const update_for_user = (
      ledger: Datatypes.ledger,
      owner: address,
      amount_: nat
   ): Datatypes.ledger =>
      Big_map.update(owner, Some(amount_), ledger);
   export const decrease_token_amount_for_user = (
      ledger: Datatypes.ledger,
      from_: address,
      amount_: nat
   ): Datatypes.ledger => {
      let tokens = get_for_user(ledger, from_);
      const _ = assert_with_error(tokens >= amount_, Errors.ins_balance);
      tokens = abs(tokens - amount_);
      return update_for_user(ledger, from_, tokens)
   };
   export const increase_token_amount_for_user = (
      ledger: Datatypes.ledger,
      to_: address,
      amount_: nat
   ): Datatypes.ledger => {
      let tokens = get_for_user(ledger, to_);
      tokens = tokens + amount_;
      return update_for_user(ledger, to_, tokens)
   }
   // Storage 

   export const get_amount_for_owner = (s: Datatypes.storage, owner: address) =>
      get_for_user(s.ledger, owner);
   export const set_ledger = (s: Datatypes.storage, ledger: Datatypes.ledger) =>
      ({ ...s, ledger: ledger });
   export const get_operators = (s: Datatypes.storage) => s.operators;
   export const set_operators = (
      s: Datatypes.storage,
      operators: Datatypes.operators
   ) =>
      ({ ...s, operators: operators })
/** transfert entrypoint*/

}

export namespace SingleAsset implements TZIP12Interface.FA2{
   export type ledger = Datatypes.ledger;
   export type operators = Datatypes.operators
   export type storage = Datatypes.storage;
   type ret = [list<operation>, storage];
   @entry
   const transfer = (t: TZIP12.transfer, s: storage): [list<operation>, storage] => {
      /* This function process the "txs" list. Since all transfer share the same "from_" address, we use a se */

      const process_atomic_transfer = (from_: address) =>
         ([ledger, t]: [ledger, TZIP12.atomic_trans]): ledger => {
            const { to_, token_id, amount } = t;
            ignore(token_id);
            const _ = Sidecar.assert_authorisation(s.operators, from_);
            let l =
               Sidecar.decrease_token_amount_for_user(ledger, from_, amount);
            return Sidecar.increase_token_amount_for_user(l, to_, amount)
         };
      const process_single_transfer = (
         [ledger, t]: [ledger, TZIP12.transfer_from]
      ): ledger => {
         const { from_, txs } = t;
         return List.fold_left(process_atomic_transfer(from_), ledger, txs)
      };
      const ledger = List.fold_left(process_single_transfer, s.ledger, t);
      const store = Sidecar.set_ledger(s, ledger);
      return [list([]), store]
   };
   /** balance_of entrypoint
*/

   @entry
   const balance_of = (b: TZIP12.balance_of, s: storage): [
      list<operation>,
      storage
   ] => {
      const { requests, callback } = b;
      const get_balance_info = (request: TZIP12.request): TZIP12.callback => {
         const { owner, token_id } = request;
         ignore(token_id);
         const balance_ = Sidecar.get_amount_for_owner(s, owner);
         return { request: request, balance: balance_ }
      };
      const callback_param = List.map(get_balance_info, requests);
      const operation =
         Tezos.transaction(Main(callback_param), 0mutez, callback);
      return [list([operation]), s]
   };
   /**
Add or Remove token operators for the specified token owners and token IDs.


The entrypoint accepts a list of update_operator commands. If two different
commands in the list add and remove an operator for the same token owner and
token ID, the last command in the list MUST take effect.


It is possible to update operators for a token owner that does not hold any token
balances yet.


Operator relation is not transitive. If C is an operator of B and if B is an
operator of A, C cannot transfer tokens that are owned by A, on behalf of B.


*/

   @entry
   const update_operators = (updates: TZIP12.update_operators, s: storage): [
      list<operation>,
      storage
   ] => {
      const update_operator = (
         [operators, update]: [operators, TZIP12.unit_update]
      ): operators =>
         match(update) {
            when (Add_operator(operator)):
               Sidecar.add_operator(
                  operators,
                  operator.owner,
                  operator.operator
               )
            when (Remove_operator(operator)):
               Sidecar.remove_operator(
                  operators,
                  operator.owner,
                  operator.operator
               )
         };
      const operators =
         List.fold_left(update_operator, Sidecar.get_operators(s), updates);
      const store = Sidecar.set_operators(s, operators);
      return [list([]), store]
   };
   @view
   const get_balance = (p: [address, nat], s: storage): nat => {
      const [owner, token_id] = p;
      Assertions.assert_token_exist(s.token_metadata, token_id);
      return match(Big_map.find_opt(owner, s.ledger)) {
         when (None()):
            0n
         when (Some(n)):
            n
      }
   };
   @view
   const total_supply = (_token_id: nat, _s: storage): nat =>
      failwith(Errors.not_available);
   @view
   const all_tokens = (_: unit, _s: storage): set<nat> =>
      failwith(Errors.not_available);
   @view
   const is_operator = (op: TZIP12.operator, s: storage): bool => {
      const authorized =
         match(Big_map.find_opt(op.owner, s.operators)) {
            when (Some(opSet)):
               opSet
            when (None()):
               Set.empty
         };
      return (Set.mem(op.operator, authorized) || op.owner == op.operator)
   };
   @view
   const token_metadata = (p: nat, s: storage): TZIP12.tokenMetadataData => {
      return match(Big_map.find_opt(p, s.token_metadata)) {
         when (Some(data)):
            data
         when (None()):
            failwith(Errors.undefined_token)
      }
   };
};
