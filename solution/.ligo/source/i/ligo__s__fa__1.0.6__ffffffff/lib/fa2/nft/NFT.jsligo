#import "../common/errors.mligo" "Errors"

export type token_id = nat;

export type owner = address;

export namespace Operators {
   type operator = address;
   export type t = big_map<[owner, operator], set<token_id>>;
   // if transfer policy is Owner_or_operator_transfer

   export const assert_authorisation = (
      operators: t,
      from_: address,
      token_id: nat
   ): unit => {
      const sender_ = (Tezos.get_sender());
      if (sender_ != from_) {
         const authorized =
            match((Big_map.find_opt([from_, sender_], operators))) {
               when (Some(a)):
                  a
               when (None):
                  Set.empty
            };
         if (! (Set.mem(token_id, authorized))) {
            return failwith(Errors.not_operator)
         }
      } else {
         return unit
      }
   };
   // if transfer policy is Owner_transfer
   // export const assert_authorisation = ([operators, from_, token_id]: [t, address, nat]): unit => {
   //    const sender_ = Tezos.sender;
   //    if (sender_ != from_)
   //       {failwith (Errors.not_owner)}
   // }
   // if transfer policy is No_transfer
   // export const assert_authorisation = ([operators, from_, token_id]: [t, address, nat]): unit =>
   //    failwith (Errors.no_owner)

   export const is_operator = (
      operators: t,
      owner: address,
      operator: address,
      token_id: nat
   ): bool => {
      const authorized =
         match(Big_map.find_opt([owner, operator], operators)) {
            when (Some(a)):
               a
            when (None):
               Set.empty
         };
      return (Set.mem(token_id, authorized) || owner == operator)
   };
   const assert_update_permission = (owner: owner): unit => {
      return assert_with_error(
         (owner == (Tezos.get_sender())),
         "The sender can only manage operators for his own token"
      )
   };
   // For an administator
   // const admin = tz1.... ;
   // assert_with_error ((Tezos.sender = admiin), "Only administrator can manage operators")

   export const add_operator = (
      operators: t,
      owner: owner,
      operator: operator,
      token_id: token_id
   ): t => {
      if (owner == operator) {
         return operators
      // assert_authorisation always allow the owner so this case is not relevant

      } else {
         assert_update_permission(owner);
         let auth_tokens =
            match(Big_map.find_opt([owner, operator], operators)) {
               when (Some(ts)):
                  ts
               when (None):
                  Set.empty
            };
         auth_tokens = Set.add(token_id, auth_tokens);
         return Big_map.update([owner, operator], Some(auth_tokens), operators)
      }
   };
   export const remove_operator = (
      operators: t,
      owner: owner,
      operator: operator,
      token_id: token_id
   ): t => {
      if (owner == operator) {
         return operators
      // assert_authorisation always allow the owner so this case is not relevant

      } else {
         assert_update_permission(owner);
         const auth_tokens: option<set<token_id>> =
            match(Big_map.find_opt([owner, operator], operators)) {
               when (Some(ts)):
                  do {
                     const toks = Set.remove(token_id, ts);
                     if (Set.cardinal(toks) == 0n) {
                        return None()
                     } else {
                        return Some(toks)
                     }
                  }
               when (None):
                  None()
            };
         return Big_map.update([owner, operator], auth_tokens, operators)
      }
   }
};

export namespace Ledger {
   export type t = big_map<token_id, owner>;
   export const is_owner_of = (ledger: t, token_id: token_id, owner: address): bool => {
      // We already sanitized token_id, a failwith here indicated a patological storage

      const current_owner = Option.unopt(Big_map.find_opt(token_id, ledger));
      return (current_owner == owner)
   };
   const assert_owner_of = (ledger: t, token_id: token_id, owner: address): unit =>
      assert_with_error(
         is_owner_of(ledger, token_id, owner),
         Errors.ins_balance
      );
   export const transfer_token_from_user_to_user = (
      ledger: t,
      token_id: token_id,
      from_: owner,
      to_: owner
   ): t => {
      assert_owner_of(ledger, token_id, from_);
      return Big_map.update(token_id, Some(to_), ledger)
   }
};

export namespace TokenMetadata {
   // This should be initialized at origination, conforming to either
   // TZIP-12 : https://gitlab.com/tezos/tzip/-/blob/master/proposals/tzip-12/tzip-12.md#token-metadata
   // or TZIP-16 : https://gitlab.com/tezos/tzip/-/blob/master/proposals/tzip-12/tzip-12.md#contract-metadata-tzip-016

   export type data = { token_id: nat, token_info: map<string, bytes> };
   export type t = big_map<nat, data>;
   const data1 =
      Map.literal(list([["name", bytes `FA2 NFT 1`], ["decimals", bytes `3`]]));
   const data3 =
      Map.literal(list([["name", bytes `FA2 NFT 3`], ["decimals", bytes `3`]]));
   export const init = (): t =>
      Big_map.literal(
         list(
            [
               [1 as nat, { token_id: 1 as nat, token_info: data1 }],
               [3 as nat, { token_id: 3 as nat, token_info: data3 }]
            ]
         )
      );
   export const get_token_metadata = (token_id: nat, tm: t): data =>
      match(Big_map.find_opt(token_id, tm)) {
         when (Some(data)):
            data
         when (None):
            failwith(Errors.undefined_token)
      }
};

#import "../common/metadata.mligo" "Metadata"

export namespace Storage {
   export type t = {
      ledger: Ledger.t,
      operators: Operators.t,
      token_ids: set<token_id>,
      token_metadata: TokenMetadata.t,
      metadata: Metadata.t
   };
   export const is_owner_of = (s: t, owner: address, token_id: token_id): bool =>
      Ledger.is_owner_of(s.ledger, token_id, owner);
   export const assert_token_exist = (s: t, token_id: nat): unit => {
      const _ =
         Option.unopt_with_error(
            Big_map.find_opt(token_id, s.token_metadata),
            Errors.undefined_token
         )
   };
   export const set_ledger = (s: t, ledger: Ledger.t): t =>
      ({ ...s, ledger: ledger });
   export const get_operators = (s: t): Operators.t => s.operators;
   export const set_operators = (s: t, operators: Operators.t): t =>
      ({ ...s, operators: operators });
   export const get_balance = (s: t, owner: address, token_id: nat): nat => {
      assert_token_exist(s, token_id);
      if (is_owner_of(s, owner, token_id)) {
         return 1n
      } else {
         return 0n
      }
   }
};

export type storage = Storage.t;

// Transfer entrypoint

export type atomic_trans = // @layout comb

   {
   to_: address,
   token_id: nat,
   amount: nat
};

export type transfer_from = { from_: address, txs: list<atomic_trans> };

export type transfer = list<transfer_from>;

@entry
const transfer = (t: transfer, s: storage): [list<operation>, storage] => {
   // This function process the "txs" list. Since all transfer share the same "from_" address, we use a se

   const process_atomic_transfer = (from_: address) =>
      ([ledger, t]: [Ledger.t, atomic_trans]): Ledger.t => {
         const { to_, token_id, amount } = t;
         ignore(amount);
         Storage.assert_token_exist(s, token_id);
         Operators.assert_authorisation(s.operators, from_, token_id);
         return Ledger.transfer_token_from_user_to_user(
            ledger,
            token_id,
            from_,
            to_
         )
      };
   const process_single_transfer = ([ledger, t]: [Ledger.t, transfer_from]): Ledger.
   t => {
      const { from_, txs } = t;
      return List.fold_left(process_atomic_transfer(from_), ledger, txs)
   };
   const ledger = List.fold_left(process_single_transfer, s.ledger, t);
   const store = Storage.set_ledger(s, ledger);
   return [list([]), store]
};

export type request = { owner: address, token_id: nat };

type callback = // @layout comb

   {
   request,
   balance: nat
};

export type balance_of = // @layout comb

   {
   requests: list<request>,
   callback: contract<list<callback>>
};

// Balance_of entrypoint

@entry
const balance_of = (b: balance_of, s: storage): [list<operation>, storage] => {
   const { requests, callback } = b;
   const get_balance_info = (request: request): callback => {
      const { owner, token_id } = request;
      Storage.assert_token_exist(s, token_id);
      let balance_ = 0 as nat;
      if (Storage.is_owner_of(s, owner, token_id)) balance_ = 1 as nat;
      return ({ request: request, balance: balance_ })
   };
   const callback_param = List.map(get_balance_info, requests);
   const operation = Tezos.transaction(callback_param, 0mutez, callback);
   return [list([operation]), s]
};

// Update_operators entrypoint

export type operator = // @layout comb

   {
   owner: address,
   operator: address,
   token_id: nat
};

export type unit_update =
   ["Add_operator", operator] | ["Remove_operator", operator];

export type update_operators = list<unit_update>;

@entry
const update_operators = (updates: update_operators, s: storage): [
   list<operation>,
   storage
] => {
   const update_operator = ([operators, update]: [Operators.t, unit_update]): Operators.
   t =>
      match(update) {
         when (Add_operator(operator)):
            Operators.add_operator(
               operators,
               operator.owner,
               operator.operator,
               operator.token_id
            )
         when (Remove_operator(operator)):
            Operators.remove_operator(
               operators,
               operator.owner,
               operator.operator,
               operator.token_id
            )
      };
   let operators = Storage.get_operators(s);
   operators = List.fold_left(update_operator, operators, updates);
   const store = Storage.set_operators(s, operators);
   return [list([]), store]
};

// If transfer_policy is  No_transfer or Owner_transfer
//const update_ops : update_operators -> storage -> operation list * storage =
//   fun (updates: update_operators) (s: storage) ->
//   const () = failwith Errors.not_supported in
//   ([]: operation list),s

@view
const get_balance = (p: [address, nat], s: storage): nat => {
   const [owner, token_id] = p;
   return Storage.get_balance(s, owner, token_id)
};

@view
const total_supply = (token_id: nat, s: storage): nat => {
   Storage.assert_token_exist(s, token_id);
   return 1n
};

@view const all_tokens = (_: unit, s: storage): set<nat> => s.token_ids;

@view
const is_operator = (op: operator, s: storage): bool =>
   Operators.is_operator(s.operators, op.owner, op.operator, op.token_id);

@view
const token_metadata = (p: nat, s: storage): TokenMetadata.data =>
   TokenMetadata.get_token_metadata(p, s.token_metadata);
